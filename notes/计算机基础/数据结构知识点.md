### 1、栈的应用

**（1）将算数表达式转换成后缀表达式（逆波兰表达式）**

假设用exp字符数组存储满足条件的简单中缀表达式，其对应的后缀表达式存放在字符数组postexp中。下面讨论几种情况。

例如，若exp="1+2+3"，转换过程是首先将操作数1存入postexp；遇到第1个“+”，尚未确定它是否最先执行，将其进栈；再将操作数2存入postexp；又遇到第2个“+”，需要两个“+”进行优先级比较，如果直接将第2个“+”进栈，它以后一定先出栈，表示第2个“+”比第1个“+”先执行，显然是错误的。正确的做法是先将栈中的第1个“+”出栈并存入postexp，然后再将第2个“+”进栈（表示第1个“+”先执行）；最后将操作数3存入postexp；此时exp扫描完毕，出栈第2个“+”并存入postexp，得到的最后结果是postexp="12+3+"。

再看看带有括号的例子，若exp="2*(1+3)-4"，转换过程是将操作数2存入postexp；遇到'\*'，将其进栈；遇到'('，将其进栈；将操作数1存入postexp；遇到'+'，将其进栈；将操作数3存入postexp；遇到')'，出栈'+'并存入postexp，出栈'('；遇到'—'，出栈'\*'并存入postexp，将‘—’进栈；将操作数4存入postexp；此时exp扫描完毕，出栈‘—’并存入postexp。得到的最后结果是postexp="2 1 3 + * 4 —"。

伪码如下：

```
while(从exp读取字符ch，ch!='\0') {
	ch为数字：将后续的所有数字均依次存放到postexp中，并以字符'#'标识数字串结束；
	ch为左括号’(‘：将括号进栈到Optr中；
	ch为右括号')'：将Optr中出栈时遇到的第一个左括号'('以前的运算符依次出栈并存放到postexp中，然后将左括号'('出栈；
	ch为其他运算符：
		if (栈空或者栈顶运算符为'(')	直接将ch进栈；
		else if (ch的优先级高于栈顶运算符的优先级)
			直接将ch进栈；
		else
			依次出栈并存入到postexp中，直到ch的优先级高于栈顶运算符，然后将ch进栈；
}
若exp扫描完毕，则将Optr中的所有运算符依次出栈并存放到postexp中。
```

对于简单的算术表达式，‘+’和‘—’运算符的优先级相同，‘\*’和‘/’运算符的优先级相同，只有‘*’和‘/’运算符的优先级高于‘+’和‘—’运算符的优先级



**（2）迷宫问题**

用mg数组作为迷宫保存

```
int mg[M+2][N+2]={
	{1,1,1,...,1,1}
	{1,1,0,...,0,1},
	...
	{0,1,0,...,1,0},
	{1,1,1,...,1,1}
}
```

栈采用顺序栈存储结构，即将迷宫栈声明如下：

```
typedef struct {
	int i, j;		// 当前方块的行号、列号
	int di;			// di是下一相邻可走方位的方位号
} Box;
typedef struct {
	Box data[MaxSize];
	int top;		// 栈顶指针
} StType;			顺序栈类型
```

设计运算算法

```
		(i-1,j)方位0
方位3			|		方位1
(i,j-1)----(i,j)-----(i,j+1)
			 |
		(i+1,j)方位2
```

若一个非出口方块（i, j）是可走的，将它进栈，每个刚刚进栈的方法，其方位di，置为—1（表示尚未试探它的周围），然后开始从方位0到方位3试探这个栈顶方块的四周，如果找到某个方位d的相邻方块（i1, j1）是可走的，则将栈顶方块（i, j）的方位di置为d，同时将方块（i1, j1）进栈，再继续从方块（i1, j1）做相同的操作。若方块（i, j）的四周没有一个方位是可走的，将它退栈，前一个方块（x, y）变成栈顶方块，再从方块（x, y）的下一个方位继续试探。

在算法中应保证试探的相邻可走方块不是已走路径上的方块。否则可能会引起死循环，为此在一个方块进栈后将对应的mg数组元素值改为—1（变为不可走的相邻方块），当退栈时（表示该栈顶方块没有可走相邻方块）将其恢复为0.

求解迷宫中从入口（xi, yi）到出口（xe, ye）的一条迷宫路径的过程如下：

```c
将入口(xi, yi)进栈（其初始方位设置为-1）;
mg[xi][yi] = -1;
while (栈不空) {
	取栈顶方块(i, j, di);
	if ((i, j)是出口(xe, ye)) {
		输出栈中的全部方块构成一条迷宫路径;
		return true;
	}
	查找(i, j, di)的下一个相邻可走方块;
	if (找到一个相邻可走方块) {
		该方块为(i1, j1)，对应方位d;
		将栈顶方块的di设置为d;
		(i1, j1, -1)出栈;
		mg[i1][j1] = -1;
	}
	if (没有找到(i, j, di)的任何相邻可走方块) {
		将(i, j, di)出栈;
		mg[i][j] = 0;
	}
}
return false;			// 没有找到迷宫路径
```


@[toc]

### 8.3 方法调用

#### 8.3.1 解析

#### 8.3.2 分派

1. **静态分派**

```java
Human man = new Man()
```

上面代码中的"*Human*"称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的“*Man*”则称为变量的实际类型（Actual Type）。

2. **动态分派**

它与重写有密切的关系。

```java
/**
 * 方法动态分派演示
 */
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }
    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        };
    }
    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        };
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

> 运行结果：
>
> man say hello
>
> woman say hello
>
> woman say hello

代码中两句（对应于反汇编后的0~15行）:

​	Human man = new Man();

​	Human woman = new Woman();

作用是建立*man*和*woman*的内存空间、调用*Man*和*Woman*类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表*Slot*中。

以下进行反汇编查看：

<img src="F:\文档\Typora Files\markdown-notes\images\notes\java\sayhello.PNG" alt="sayhello" style="zoom:80%;" />

16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的*sayHello()*方法的所有者，称为`Receiver`；

17、21句是方法调用指令，这两条指令单从字节码的角度来说完全一样，但是最终的执行目标方法却不一样。这是因为*invokevirtual*指令的多态查找过程，如下：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符和简单名称相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回*java.lana.IllegalAccessError*异常。
3. 否则，继续按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出*java.lang.AbstractMethodError*异常。

由于*invokevirtual*指令执行的第一步就是在**运行期**确定接收者的实际类型，所以两次调用中指令都是把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是*java*语言中方法重写的本质。而这种**在运行期根据实际类型确定方法执行版本的分派过程称为动态分派**。

3. **单分派与多分派**

方法的接收者与方法的参数统称为方法的**宗量**，这个定义最早来自于《Java与模式》。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

代码案例如下：

```java
/**
 * 单分派、多分派演示
 */
public class Dispatch {
    static class QQ {}
    static class _360 {}
    public static class Father {
        public void hardChoice(QQ arg) {
            System.out.println("father choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("father choose 360");
        }
    }
    public static class Son extends Father {
        public void hardChoice(QQ arg) {
            System.out.println("son choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("son choose 360");
        }
    }
    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ);
    }
}
```

> 运行结果：
>
> father choose 360
>
> son choose qq

首先来看看编译器的选择过程（静态分派的过程）。这时选择目标方法的依据有两点：一是静态类型是*Father*还是*Son*，二是方法参数是*QQ*还是*360*。这次选择结果的最终产物是产生了两条*invokevirtual*指令，两条指令的参数分别为常量池中指向*Father.hardChoice(360)*及*Father.hardChoice(QQ)*方法的符号引用。**因为是根据两个宗量进行选择，所以*Java*语言的静态分派属于多分派类型。**

再看看运行阶段虚拟机的选择（动态分派的过程）。在执行"*son.hardChoice(new QQ())*"所对应的*invokevirtual*指令时，由于编译期已经决定目标方法的签名必须为*hardChoice(QQ)*，虚拟机此时不会关心传递过来的参数"*QQ*"到底是“*腾讯QQ*”还是“*奇瑞QQ*”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是*Father*还是*Son*。**因为只有一个宗量作为选择依据，所以*Java*语言的动态分派属于单分派类型。**

按照目前*Java*语言的发展趋势，并没有直接变为动态语言的迹象，而是通过**内置动态语言（如*JavaScript*）执行引擎**的方式来满足动态性的需求。但是在*Java*虚拟机层面上则不是如此，在**JDK 1.7**中实现的**JSR-292**里面就已经开始提供对动态语言的支持了，**JDK 1.7**中新增的__*invokedynamic*指令__也成为了最复杂的一条方法调用的字节码指令。

4. **虚拟机动态分派的实现**

<u>虚拟机在分派中“具体是如何做到的”？</u>

由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此虚拟机实际实现中基于性能的考虑，大部分不会真正的进行如此频繁的搜索。

最常用的“**稳定优化**”手段就是为类在方法区建立一个**虚方法表**（*vtable*，对应的，在*invokeinterface*执行时也会用到**接口方法表**——*itable*），使用虚方法表索引来代替元数据查找以提高性能。

<img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3602393455,2423916211&amp;fm=26&amp;gp=0.jpg" style="zoom:80%;" />

虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类重写了，那么就会替换为指向子类实现版本的入口地址。

**图8-3中，*Son*重写了来自*Father*的全部方法，因此*Son*的方法表中没有指向*Father*类型数据的箭头。但是*Son*和*Father*都没有重写来自*Object*的方法，所以它们的方法表中所有从*Object*继承来的方法都指向了*Object*的数据类型。**

为了实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。

方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把该类的方法表也初始化完毕。

另外除了方法表这种“稳定优化”手段之外，虚拟机还可能在一些情况下使用**内联缓存**和基于“**类型继承关系的分析（CHA）**”技术的**守护内联**两种非稳定的“激进优化”手段。

####  8.3.3 动态类型语言支持

`invokedynamic`指令是**JDK 1.7**实现“动态类型语言”支持而进行的改进之一，也是为**JDK 1.8**实现`Lambda`表达式做技术准备。

1. **动态类型语言**

<u>什么是动态类型语言？</u>

动态语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期，满足的语言包括：*Groovy、JavaScript、Jython、PHP、Python、Ruby、Smalltalk*。相对的，在编译期就进行类型检查过程的语言（*C++、Java*）就是最常用的静态类型语言。

如下案例：

```java
public static void main(String[] args) {
    int[][][] array = new int[1][0][-1];
}
```

这段代码能够正常编译，但运行时会报*NegativeArraySizeException*异常。
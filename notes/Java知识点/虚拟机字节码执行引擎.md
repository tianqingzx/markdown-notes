@[toc]

### 8.3 方法调用

#### 8.3.1 解析

#### 8.3.2 分派

1. **静态分派**

```java
Human man = new Man()
```

上面代码中的"*Human*"称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的“*Man*”则称为变量的实际类型（Actual Type）。

2. **动态分派**

它与重写有密切的关系。

```java
/**
 * 方法动态分派演示
 */
public class DynamicDispatch {
    static abstract class Human {
        protected abstract void sayHello();
    }
    static class Man extends Human {
        @Override
        protected void sayHello() {
            System.out.println("man say hello");
        };
    }
    static class Woman extends Human {
        @Override
        protected void sayHello() {
            System.out.println("woman say hello");
        };
    }
    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        man.sayHello();
        woman.sayHello();
        man = new Woman();
        man.sayHello();
    }
}
```

> 运行结果：
>
> man say hello
>
> woman say hello
>
> woman say hello

代码中两句（对应于反汇编后的0~15行）:

​	Human man = new Man();

​	Human woman = new Woman();

作用是建立*man*和*woman*的内存空间、调用*Man*和*Woman*类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表*Slot*中。

以下进行反汇编查看：

<img src="F:\文档\Typora Files\markdown-notes\images\notes\java\sayhello.PNG" alt="sayhello" style="zoom:80%;" />

16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的*sayHello()*方法的所有者，称为`Receiver`；

17、21句是方法调用指令，这两条指令单从字节码的角度来说完全一样，但是最终的执行目标方法却不一样。这是因为*invokevirtual*指令的多态查找过程，如下：

1. 找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。
2. 如果在类型C中找到与常量中的描述符和简单名称相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回*java.lana.IllegalAccessError*异常。
3. 否则，继续按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。
4. 如果始终没有找到合适的方法，则抛出*java.lang.AbstractMethodError*异常。

由于*invokevirtual*指令执行的第一步就是在**运行期**确定接收者的实际类型，所以两次调用中指令都是把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是*java*语言中方法重写的本质。而这种**在运行期根据实际类型确定方法执行版本的分派过程称为动态分派**。

3. **单分派与多分派**

方法的接收者与方法的参数统称为方法的**宗量**，这个定义最早来自于《Java与模式》。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。

代码案例如下：

```java
/**
 * 单分派、多分派演示
 */
public class Dispatch {
    static class QQ {}
    static class _360 {}
    public static class Father {
        public void hardChoice(QQ arg) {
            System.out.println("father choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("father choose 360");
        }
    }
    public static class Son extends Father {
        public void hardChoice(QQ arg) {
            System.out.println("son choose qq");
        }
        public void hardChoice(_360 arg) {
            System.out.println("son choose 360");
        }
    }
    public static void main(String[] args) {
        Father father = new Father();
        Father son = new Son();
        father.hardChoice(new _360());
        son.hardChoice(new QQ);
    }
}
```

> 运行结果：
>
> father choose 360
>
> son choose qq
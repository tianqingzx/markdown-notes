# 第1章初识C语言
#### 1.6 语言标准
**第一个ANSI/ISO C标准**

美国国家标准协会（ANSI）于1983年组建了一个委员会（X3J11），开发了一套新标准，并于1989年正式公布。该标准（ANSI C）定义了C语言和C标准库。国际标准化组织于1990年采用了这套C标准(ISO C)。ISO C和ANSI C是完全相同的标准。ANSI/ISO标准的最终版本通常叫作*C89*（因为ANSI 于 1989 年批准该标准）或*C90*（因为ISO于1990年批准该标准）。另外，由于ANSI先公布C标准，因此业界人士通常使用 ANSI C。

**C99标准**

1994年，ANSI/ISO联合委员会（C9X委员会）开始修订C标准，最终发布了C99标准。其达成的新目标：
- 第1，支持国际化编程。例如提供多种方法处理国际字符集。
- 第2，弥补缺陷。对于C移至64位处理器时，添加标准。
- 第3，适应科学和工程项目中的关键数值计算，提高C的适应性。

**C11标准**

标准委员会在2007年承诺C标准的下一个版本是C1X，2011年终于发布了C11标准。出于对当前编程安全的担忧，不那么强调“信任程序员”目标了。同时并未很好地接受和支持C99，使得C99的一些特性成为了C11的可选项。新标准添加了可选项支持当前使用多处理器的计算机。

#### 1.8 编程机制
**GUN编译器集合和LLVM项目**

GUN项目始于1987年，是一个开发大量自由UNIX软件的集合（GUN的意思是“GUN's Not UNIX”，即GUN不是UNIX）。GUN编译器集合（也被称为GCC，其中包含GCC C编译器）是该项目的产品之一。用gcc命令即可调用GCC C编译器。许多使用gcc的系统都用cc作为gcc的别名。

LLVM项目成为cc的另一个替代品。该项目是与编译器相关的开源软件集合，始于伊利诺大学2000年的研究项目。它的Clang编译器处理C代码，可以通过clang调用。

GUN和LLVM都可以用-v选项来显示版本信息，因此各系统都使用cc别名来代替gcc或clang命令。以下组合：
```c
cc -v
```
显示你所使用的编译器及其版本。
gcc和clang命令都可以根据不同的版本选择运行时选项来调用不同C标准。
```c
gcc -std=c99 inform.c
gcc -std=c1x inform.c
gcc -std=c11 inform.c
```
第一行调用C99标准，第2行调用GCC接受C11之前的草案标准，第3行调用GCC接受的C11标准版本。Clang编译器在这一点上用法与GCC相同。

# 第2章 C语言概述
#### 2.2 语言风格
**命名**

C99和C11允许使用更长的标识符名，但是编译器只识别前63个字符。对于外部标识符，只允许使用31个字符。

操作系统和C库经常使用以一个或两个下划线字符开始的标识符（如，_kcab），因此最好避免在自己的程序中使用这种名称。标准标签都以一个或两个下划线字符开始，如库标识符。这样的标识符都是保留的。**同时C语言的名称区分大小。**

C99之前的标准要求把声明都置于块的顶部，这样规定的好处是：把声明放在一起更容易理解程序的用途。C99允许在需要时才声明变量，这样做的好处是：在给变量赋值之前声明变量，就不会忘记给变量赋值。

**函数调用语句：**在历年的C标准中从来没有函数调用语句！值得一提的是，函数调用本身是一个表达式，圆括号是运算符，圆括号左边的函数名是运算对象。在C11标准中，这样的表达式是一种后缀表达式。在表达式末尾加上分号，就成了表达式语句。

#### 2.7 调试程序
**语法错误**：指把有效的C符号放在错误的地方，不遵守C语言的规则就会犯语法错误。

**语义错误**：如果遵循了C规则，但是结果不正确，那就是犯了语义错误。例如逻辑上的错误，编译器无法检测出。

#### 2.8 关键字和保留标识符
ISO C关键字：

| C90      |          |         | C99      | C11            |               |
| -------- | -------- | ------- | -------- | -------------- | ------------- |
| auto     | extern   | short   | const    | _Alignas       | _Thread_local |
| break    | float    | sizeof  | enum     | _Alignof       |               |
| case     | for      | static  | signed   | _Atomic        |               |
| continue | goto     | struct  | void     | _Bool          |               |
| default  | if       | switch  | volatile | _Complex       |               |
| do       | inline   | typedef |          | _Generic       |               |
| double   | int      | union   |          | _Imaginary     |               |
| else     | long     |         |          | _Noreturn      |               |
| while    | unsigned |         |          | _Static_assert |               |

保留标识符包括那些以下划线字符开头的标识符和标准库函数名，如printf()。

# 第3章 数据和C
#### 3.1 程序讲解
```c
printf("%f", num)   // 打印浮点值
printf("%.2f", num) // .2用于精确控制输出小数点后两位
```

#### 3.3 数据类型关键字
C语言的数据类型关键字：

| 最初K&R给出的关键字 | C90标准添加的关键字 | C99标准添加的关键字 |
| ------------------- | ------------------- | ------------------- |
| int                 | signed              | _Bool               |
| long                | void                | _Complex            |
| short               |                     | _Imaginary          |
| unsigned            |                     |                     |
| char                |                     |                     |
| float               |                     |                     |
| double              |                     |                     |

按计算机的存储方式可分为两大基本类型：整数类型和浮点数类型。

#### 3.4 C语言基本数据类型

**八进制和十六进制**

0x或0X前缀表示十六进制值，0前缀表示八进制。

以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。

**整数类型**

short ：16位

int：16位或32位

long：32位；要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀。l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。

long long ：64位；使用ll或LL后缀来表示long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如5ull、10LLU、6LLU或9Ull。

C语言提供3个附属关键字修饰基本整数类型：short、long、signed和unsigned。

**打印short、long、long long和unsigned类型**

打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能使用小写。

对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值，%lld和%llu分别表示long long的有符号和无符号类型。

```c
unsigned int un = 3000000000;
short end = 200;
long big = 65537;
long long verybig = 12345678908642;

printf("un = %u and not %d\n", un, un);			// un = 3000000000 and not -1294967296
printf("end = %hd and %d\n", end, end);			// end = 200 and 200
printf("big = %ld and not %hd\n", big, big);	// big = 65537 and not 1
printf("verybig = %lld and not %ld\n", verybig, verybig);	// verybig = 12345678908642 and not 1942899938
```

**使用字符**

非打印字符：

单引号只适用于字符、数字和标点符号，有些ASCII字符打印不出来。

第1种方法是使用ASCII码：`char beepc = 7;`

第2种方法是使用转义序列：`char nerf = '\n';`

| 转义序列 | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| \\a      | 警报，C标准规定警报字符不得改变活跃位置                      |
| \\b      | 退格                                                         |
| \\f      | 换页，将活跃位置移至下一页的开始处                           |
| \\n      | 换行，把活跃位置移至下一行的开始处                           |
| \\r      | 回车，把活跃位置移至当前行的开始处                           |
| \\t      | 水平制表符，把活跃位置移至下一个水平制表点（常是第1、9、17、25个等字符位置） |
| \\v      | 垂直制表符，把活跃位置移至下一个垂直制表点                   |
| \\\      | 反斜杠（\）                                                  |
| \\'      | 单引号                                                       |
| \\"      | 双引号                                                       |
| \\?      | 问号                                                         |
| \\0oo    | 八进制值（oo必须是有效的八进制数，即每个o可表示0~7中的一个数） |
| \\xhh    | 十六进制值（hh必须是有效的十六进制数，即每个h可表示0~f中的一个数） |

*活跃位置*：显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，屏幕光标位置就是活跃位置。

这些转义序列字符不一定在所有显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。

打印字符：

printf()函数用%c指明待打印的字符。printf()函数中的转换说明决定了数据的显示方式，而不是数据的存储方式。

**可移植类型：stdint.h和inttypes.h**

精确宽度整数类型（可选项）：`int32_t`表示整数类型的宽度正好是32位。

最小宽度类型：至少有指定宽度的最小整数类型。例如，`int_least8_t`是可容纳8位有符号整数的类型中宽度最小的类型的一个别名。

最快最小宽度类型：一组可使计算达到最快的类型集合。例如，`int_fast8_t`被定义为系统中对8位有符号值而言运算最快的整数类型的别名。

最大整数类型：`intmax_t`为最大的有符号整数类型，`uintmax_t`表示最大的无符号整数类型。

printf()打印特定类型时要求与相应的转换说明匹配。inttypes.h头文件提供了一些字符串宏来显示可移植类型。例如，`PRId32`字符串宏，代表打印32位有符号值的合适转换说明

```c
printf("me32 = %" PRId32 "\n", me32);
```

**float、double和long double**

浮点型常量：

```c
-1.56E+12
2.87e-3

3.14159
.2
4e16
.8E-5
100.
```

默认情况下，编译器假定浮点型常量是double类型的精度。

在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。没有后缀的浮点型常量是double类型。

C99标准添加了十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。`0xa.1fp10`

打印浮点值：

printf()函数使用%f转换说明打印十进制计数法的float和double类型浮点数，用%e打印指数计数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）传递参数时，C编译器会把float类型的值自动转换成double类型。

还有另外一个特殊的浮点值NaN（not a number），表示函数的行为是未定义的，例如超出定义域。

**复数和虚数类型**

3种复数类型：float _Complex、double _Complex、long double _Complex，例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。

3种虚数类型：float _Imaginary、double _Imaginary、long double _Imaginary

如果包含complex.h头文件，便可用complex代替\_Complex，用imaginary代替\_Imaginary，还可以用I代替-1的平方根。

**类型大小**

sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型（即size_t类型）。一些不支持C99和C11的编译器可用%u或%lu代替%zd。

#### 3.5 使用数据类型

```c
int cost = 12.99;			// 用double类型的值初始化int类型的变量
float pi = 3.1415926536;	// 用double类型的值初始化float类型的变量
```

第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。

第2个声明会损失一些精度，因为C只保证了float类型前6位的精度



*用i\_前缀表示int类型，us\_前缀表示unsigned short类型。*



**参数和陷阱**

printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。printf()和scanf()函数用第1个参数表明后续有多少个参数。

注意，用%d显示float类型的值，其值不会被转换成int类型。

#### 3.7 转义序列示例

**刷新输出**

最初，prinf()语句把输出发送到*缓冲区*的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C标准明确规定了何时把缓冲区中的内容发送到屏幕：当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。

还有一种刷新缓冲区的方法是使用fflush()函数。

